task prepareRelease {
    outputs.upToDateWhen { false }
    doLast {
        // Check repository for uncommitted changes...
        def status
        new ByteArrayOutputStream().withStream { os ->
            project.rootProject.exec {
                workingDir project.rootProject.rootDir
                commandLine 'git'
                args 'status', '--porcelain'
                standardOutput = os
            }
            status = os.toString()
        }

        if (status != null && !status.equals("")) {
            throw new GradleException("Repository is dirty - cannot publish releases from a repository containing uncommited changes.")
        }

        // TODO : Create version file if missing
        // Set release version by removing -SNAPSHOT...
        def versionFile = new File("${project.rootProject.rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()
        def newVersion = currentVersion.replace('-SNAPSHOT', '')
        versionFile.write(newVersion)

        // Add and commit new version...
//        project.rootProject.exec {
//            workingDir project.rootProject.rootDir
//            commandLine 'git'
//            args 'add', 'version.txt'
//        }
//        project.rootProject.exec {
//            workingDir project.rootProject.rootDir
//            commandLine 'git'
//            args 'commit', '-m', "prepare release ${newVersion}"
//        }

        println "Ready to release version ${newVersion}"
    }
}

task startNextMinorVersion() {
    outputs.upToDateWhen { false }
    doLast {
        // Get current version
        // TODO : Use project.version
        def versionFile = new File("${project.rootProject.rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        // Calculate next version
        def newVersion;
        if (project.hasProperty("nextVersion")) {
            newVersion = nextVersion
        } else {
            // TODO : Increase either major, minor or patch
            currentVersion = currentVersion.replace('-SNAPSHOT', '')
            def split = currentVersion.split('\\.', 3)
            def newMajorVersion = split[0].toInteger()
            def newMinorVersion = split[1].toInteger() + 1
            def newPatchVersion = 0
            newVersion = newMajorVersion + '.' + newMinorVersion + '.' + newPatchVersion + '-SNAPSHOT'
        }

        // Set next snapshot version
        versionFile.write(newVersion)

        // Commit new version
//        project.rootProject.exec {
//            workingDir project.rootProject.rootDir
//            commandLine 'git'
//            args 'add', 'version.txt'
//        }
//        project.rootProject.exec {
//            workingDir project.rootProject.rootProject.rootDir
//            commandLine 'git'
//            args 'commit', '-m', "prepare next version ${newVersion}"
//        }

        // Push all, including tag
//        project.rootProject.exec {
//            workingDir project.rootProject.rootDir
//            commandLine 'git'
//            args 'push', '--follow-tags'
//        }

        println 'release done!'
        println 'Goto https://bintray.com/buchandersenn/maven/android-realm-builders and release the published artifacts'
    }
}

//task publishRelease(dependsOn: 'prepareNextSnapshot') {
//    outputs.upToDateWhen { false }
//    doLast {
//        println 'release done!'
//        println 'Goto https://bintray.com/buchandersenn/maven/android-realm-builders and release the published artifacts'
//    }
//}
//
//task prepareNextSnapshot(dependsOn: 'finishRelease') {
//    outputs.upToDateWhen { false }
//    doLast {
//        // Get current version
//        def versionFile = new File("${rootDir}/version.txt")
//        def currentVersion = versionFile.text.trim()
//
//        // Calculate next version
//        def newVersion;
//        if (project.hasProperty("nextVersion")) {
//            newVersion = nextVersion
//        } else {
//            def split = currentVersion.split('3', 3)
//            def newMajorVersion = split[0].toInteger()
//            def newMinorVersion = split[1].toInteger() + 1
//            def newPatchVersion = 0
//            newVersion = newMajorVersion + '.' + newMinorVersion + '.' + newPatchVersion + '-SNAPSHOT'
//        }
//
//        // Set next snapshot version
//        versionFile.write(newVersion)
//
//        // Commit new version
//        exec {
//            workingDir rootDir
//            commandLine 'git'
//            args 'add', 'version.txt'
//        }
//        exec {
//            workingDir rootDir
//            commandLine 'git'
//            args 'commit', '-m', "prepare next version ${newVersion}"
//        }
//
//        // Push all, including tag
//        exec {
//            workingDir rootDir
//            commandLine 'git'
//            args 'push', '--follow-tags'
//        }
//    }
//}
//
//task finishRelease(dependsOn: 'bintrayUploadAll') {
//    outputs.upToDateWhen { false }
//    doLast {
//        // Get version
//        def versionFile = new File("${rootDir}/version.txt")
//        def currentVersion = versionFile.text.trim()
//
//        // Tag release
//        exec {
//            workingDir rootDir
//            commandLine 'git'
//            args 'tag', '-a', 'v' + currentVersion, '-m', 'version ' + currentVersion
//        }
//    }
//}
//
//task bintrayUploadAll(dependsOn: 'cleanAll') {
////    subprojects.each {
////        it.afterEvaluate {
////            def cleanTask = it.tasks.findByName('bintrayUpload')
////            if (cleanTask) {
////                dependsOn(cleanTask)
////            }
////        }
////    }
//}
//
//task cleanAll(dependsOn: 'prepareRelease') {
//    subprojects.each {
//        it.afterEvaluate {
//            def cleanTask = it.tasks.findByName('clean')
//            if (cleanTask) {
//                dependsOn(cleanTask)
//            }
//        }
//    }
//}
//
//task prepareRelease(dependsOn: 'checkRepo') {
//    outputs.upToDateWhen { false }
//    doLast {
//        // Set release version by removing -SNAPSHOT
//        def versionFile = new File("${rootDir}/version.txt")
//        def currentVersion = versionFile.text.trim()
//        def newVersion = currentVersion.replace('-SNAPSHOT', '')
//        versionFile.write(newVersion)
//
//        // Commit new version
//        exec {
//            workingDir rootDir
//            commandLine 'git'
//            args 'add', 'version.txt'
//        }
//        exec {
//            workingDir rootDir
//            commandLine 'git'
//            args 'commit', '-m', "prepare release ${newVersion}"
//        }
//    }
//    onlyIf { !(project.hasProperty('snapshot') && snapshot.toBoolean())}
//}
//
//task checkRepo {
//    outputs.upToDateWhen { false }
//    doLast {
//        def status
//        new ByteArrayOutputStream().withStream { os ->
//            exec {
//                workingDir rootDir
//                commandLine 'git'
//                args 'status', '--porcelain'
//                standardOutput = os
//            }
//            status = os.toString()
//        }
//
//        if (status != null && !status.equals("")) {
//            throw new GradleException("repo is dirty - cannot publish releases from a repository containing uncommited changes")
//        }
//    }
//}
