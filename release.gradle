def MAJOR = 0
def MINOR = 0
def PATCH = 0

task prepareRelease {
    outputs.upToDateWhen { false }
    doLast {
        // Check repository for uncommitted changes...
        def status
        new ByteArrayOutputStream().withStream { os ->
            project.rootProject.exec {
                workingDir project.rootProject.rootDir
                commandLine 'git'
                args 'status', '--porcelain'
                standardOutput = os
            }
            status = os.toString()
        }

        if (status != null && !status.equals("")) {
            throw new GradleException("Repository is dirty - cannot publish releases from a repository containing uncommited changes.")
        }

        // TODO : Create version file if missing
        // Set release version by removing -SNAPSHOT...
        def versionFile = new File("${project.rootProject.rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()
        def newVersion = currentVersion.replace('-SNAPSHOT', '')
        versionFile.write(newVersion)

        // Add and commit new version...
        project.rootProject.exec {
            workingDir project.rootProject.rootDir
            commandLine 'git'
            args 'add', 'version.txt'
        }
        project.rootProject.exec {
            workingDir project.rootProject.rootDir
            commandLine 'git'
            args 'commit', '-m', "prepare release ${newVersion}"
        }

        println "Ready to release version ${newVersion}"
    }
}

task finishRelease {
    outputs.upToDateWhen { false }
    doLast {
        def versionFile = new File("${rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        tagRelease(currentVersion)
        increaseVersion(versionFile, currentVersion, PATCH)
        commitVersionAndPush(newVersion)

        println "Release of version ${currentVersion} done!"
        println "Started development of next patch version: ${newVersion}"
    }
}

task finishReleaseAndUpgradeMinor {
    outputs.upToDateWhen { false }
    doLast {
        def versionFile = new File("${rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        tagRelease(currentVersion)
        increaseVersion(versionFile, currentVersion, MINOR)
        commitVersionAndPush(newVersion)

        println "Release of version ${currentVersion} done!"
        println "Started development of next patch version: ${newVersion}"
    }
}

task finishReleaseAndUpgradeMajor {
    outputs.upToDateWhen { false }
    doLast {
        def versionFile = new File("${rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        tagRelease(currentVersion)
        increaseVersion(versionFile, currentVersion, MAJOR)
        commitVersionAndPush(newVersion)

        println "Release of version ${currentVersion} done!"
        println "Started development of next patch version: ${newVersion}"
    }
}

def tagRelease(currentVersion) {
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'tag', '-a', 'v' + currentVersion, '-m', 'version ' + currentVersion
    }
}

def increaseVersion(versionFile, currentVersion, type) {
    def newVersion

    if (project.hasProperty("nextVersion")) {
        newVersion = nextVersion
    } else {
        currentVersion = currentVersion.replace('-SNAPSHOT', '')
        def split = currentVersion.split('\\.', 3)
        def version = [
                split[MAJOR].toInteger(),
                split[MINOR].toInteger(),
                split[PATCH].toInteger(),
        ]

        switch (type) {
            case MAJOR:
                version[MAJOR] += 1
                version[MINOR] = 0
                version[PATCH] = 0
                break
            case MINOR:
                version[MINOR] += 1
                version[PATCH] = 0
                break
            case PATCH:
                version[PATCH] += 1
                break
        }

        newVersion = version[MAJOR] + '.' + version[MINOR] + '.' + version[PATCH] + '-SNAPSHOT'
    }

    versionFile.write(newVersion)

    return newVersion
}

def commitVersionAndPush(newVersion) {
    // Commit new version
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'add', 'version.txt'
    }
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'commit', '-m', "prepare next version ${newVersion}"
    }

    // Push version, including tag
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'push', '--follow-tags'
    }
}