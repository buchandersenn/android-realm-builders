task prepareRelease {
    outputs.upToDateWhen { false }
    doLast {
        // Check repository for uncommitted changes...
        def status
        new ByteArrayOutputStream().withStream { os ->
            project.rootProject.exec {
                workingDir project.rootProject.rootDir
                commandLine 'git'
                args 'status', '--porcelain'
                standardOutput = os
            }
            status = os.toString()
        }

        if (status != null && !status.equals("")) {
            throw new GradleException("Repository is dirty - cannot publish releases from a repository containing uncommited changes.")
        }

        // TODO : Create version file if missing
        // Set release version by removing -SNAPSHOT...
        def versionFile = new File("${project.rootProject.rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()
        def newVersion = currentVersion.replace('-SNAPSHOT', '')
        versionFile.write(newVersion)

        // Add and commit new version...
        project.rootProject.exec {
            workingDir project.rootProject.rootDir
            commandLine 'git'
            args 'add', 'version.txt'
        }
        project.rootProject.exec {
            workingDir project.rootProject.rootDir
            commandLine 'git'
            args 'commit', '-m', "prepare release ${newVersion}"
        }

        println "Ready to release version ${newVersion}"
    }
}

task finishRelease {
    outputs.upToDateWhen { false }
    doLast {
        def versionFile = new File("${rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        // Tag just released version...
        tagRelease(currentVersion)

        // Prepare for next -SNAPSHOT version
        def newVersion = increaseVersion(versionFile, currentVersion, "patch")
        commitVersionAndPush(newVersion)

        println "Release of version ${currentVersion} done!"
        println "Started development of next patch version: ${newVersion}"
    }
}

task finishReleaseAndUpgradeMinor {
    outputs.upToDateWhen { false }
    doLast {
        def versionFile = new File("${rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        // Tag just released version...
        tagRelease(currentVersion)

        // Prepare for next -SNAPSHOT version
        def newVersion = increaseVersion(versionFile, currentVersion, "minor")
        commitVersionAndPush(newVersion)

        println "Release of version ${currentVersion} done!"
        println "Started development of next patch version: ${newVersion}"
    }
}

task finishReleaseAndUpgradeMajor {
    outputs.upToDateWhen { false }
    doLast {
        def versionFile = new File("${rootDir}/version.txt")
        def currentVersion = versionFile.text.trim()

        // Tag just released version...
        tagRelease(currentVersion)

        // Prepare for next -SNAPSHOT version
        def newVersion = increaseVersion(versionFile, currentVersion, "major")
        commitVersionAndPush(newVersion)

        println "Release of version ${currentVersion} done!"
        println "Started development of next patch version: ${newVersion}"
    }
}

def tagRelease(currentVersion) {
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'tag', '-a', 'v' + currentVersion, '-m', 'version ' + currentVersion
    }
}

def increaseVersion(versionFile, currentVersion, upgrade) {
    def newVersion

    if (project.hasProperty("nextVersion")) {
        newVersion = nextVersion
    } else {
        currentVersion = currentVersion.replace('-SNAPSHOT', '')
        def split = currentVersion.split('\\.', 3)
        def version = [
                split[0].toInteger(),
                split[1].toInteger(),
                split[2].toInteger(),
        ]

        switch (upgrade) {
            case "major":
                version[0] += 1
                version[1] = 0
                version[2] = 0
                break
            case "minor":
                version[1] += 1
                version[2] = 0
                break
            case "patch":
                version[2] += 1
                break
        }

        newVersion = version[0] + '.' + version[1] + '.' + version[2] + '-SNAPSHOT'
    }

    versionFile.write(newVersion)

    return newVersion
}

def commitVersionAndPush(newVersion) {
    // Commit new version
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'add', 'version.txt'
    }
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'commit', '-m', "prepare next version ${newVersion}"
    }

    // Push version, including tag
    exec {
        workingDir rootDir
        commandLine 'git'
        args 'push', '--follow-tags'
    }
}